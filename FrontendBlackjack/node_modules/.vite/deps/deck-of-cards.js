import "./chunk-TCQZMY3T.js";

// node_modules/deck-of-cards/lib/createElement.js
function createElement_default(type) {
  return document.createElement(type);
}

// node_modules/deck-of-cards/lib/animationFrames.js
var ticking;
var animations = [];
function animationFrames_default(delay, duration) {
  var now = Date.now();
  var start = now + delay;
  var end = start + duration;
  var animation = {
    start,
    end
  };
  animations.push(animation);
  if (!ticking) {
    ticking = true;
    requestAnimationFrame(tick);
  }
  var self = {
    start: function(cb) {
      animation.startcb = cb;
      return self;
    },
    progress: function(cb) {
      animation.progresscb = cb;
      return self;
    },
    end: function(cb) {
      animation.endcb = cb;
      return self;
    }
  };
  return self;
}
function tick() {
  var now = Date.now();
  if (!animations.length) {
    ticking = false;
    return;
  }
  for (var i = 0, animation; i < animations.length; i++) {
    animation = animations[i];
    if (now < animation.start) {
      continue;
    }
    if (!animation.started) {
      animation.started = true;
      animation.startcb && animation.startcb();
    }
    var t = (now - animation.start) / (animation.end - animation.start);
    animation.progresscb && animation.progresscb(t < 1 ? t : 1);
    if (now > animation.end) {
      animation.endcb && animation.endcb();
      animations.splice(i--, 1);
      continue;
    }
  }
  requestAnimationFrame(tick);
}
window.requestAnimationFrame || (window.requestAnimationFrame = function(cb) {
  setTimeout(cb, 0);
});

// node_modules/deck-of-cards/lib/ease.js
var ease_default = {
  linear: function(t) {
    return t;
  },
  quadIn: function(t) {
    return t * t;
  },
  quadOut: function(t) {
    return t * (2 - t);
  },
  quadInOut: function(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  },
  cubicIn: function(t) {
    return t * t * t;
  },
  cubicOut: function(t) {
    return --t * t * t + 1;
  },
  cubicInOut: function(t) {
    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
  },
  quartIn: function(t) {
    return t * t * t * t;
  },
  quartOut: function(t) {
    return 1 - --t * t * t * t;
  },
  quartInOut: function(t) {
    return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
  },
  quintIn: function(t) {
    return t * t * t * t * t;
  },
  quintOut: function(t) {
    return 1 + --t * t * t * t * t;
  },
  quintInOut: function(t) {
    return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
  }
};

// node_modules/deck-of-cards/lib/fontSize.js
function fontSize_default() {
  return window.getComputedStyle(document.body).getPropertyValue("font-size").slice(0, -2);
}

// node_modules/deck-of-cards/lib/modules/bysuit.js
var fontSize;
var bysuit_default = {
  deck: function(deck) {
    deck.bysuit = deck.queued(bysuit);
    function bysuit(next) {
      var cards = deck.cards;
      fontSize = fontSize_default();
      cards.forEach(function(card) {
        card.bysuit(function(i) {
          if (i === cards.length - 1) {
            next();
          }
        });
      });
    }
  },
  card: function(card) {
    var rank = card.rank;
    var suit = card.suit;
    card.bysuit = function(cb) {
      var i = card.i;
      var delay = i * 10;
      card.animateTo({
        delay,
        duration: 400,
        x: -Math.round((6.75 - rank) * 8 * fontSize / 16),
        y: -Math.round((1.5 - suit) * 92 * fontSize / 16),
        rot: 0,
        onComplete: function() {
          cb(i);
        }
      });
    };
  }
};

// node_modules/deck-of-cards/lib/modules/fan.js
var fontSize2;
var fan_default = {
  deck: function(deck) {
    deck.fan = deck.queued(fan);
    function fan(next) {
      var cards = deck.cards;
      var len = cards.length;
      fontSize2 = fontSize_default();
      cards.forEach(function(card, i) {
        card.fan(i, len, function(i2) {
          if (i2 === cards.length - 1) {
            next();
          }
        });
      });
    }
  },
  card: function(card) {
    var $el = card.$el;
    card.fan = function(i, len, cb) {
      var z = i / 4;
      var delay = i * 10;
      var rot = i / (len - 1) * 260 - 130;
      card.animateTo({
        delay,
        duration: 300,
        x: -z,
        y: -z,
        rot: 0
      });
      card.animateTo({
        delay: 300 + delay,
        duration: 300,
        x: Math.cos(deg2rad(rot - 90)) * 55 * fontSize2 / 16,
        y: Math.sin(deg2rad(rot - 90)) * 55 * fontSize2 / 16,
        rot,
        onStart: function() {
          $el.style.zIndex = i;
        },
        onComplete: function() {
          cb(i);
        }
      });
    };
  }
};
function deg2rad(degrees) {
  return degrees * Math.PI / 180;
}

// node_modules/deck-of-cards/lib/prefix.js
var style = document.createElement("p").style;
var memoized = {};
function prefix_default(param) {
  if (typeof memoized[param] !== "undefined") {
    return memoized[param];
  }
  if (typeof style[param] !== "undefined") {
    memoized[param] = param;
    return param;
  }
  var camelCase = param[0].toUpperCase() + param.slice(1);
  var prefixes = ["webkit", "moz", "Moz", "ms", "o"];
  var test;
  for (var i = 0, len = prefixes.length; i < len; i++) {
    test = prefixes[i] + camelCase;
    if (typeof style[test] !== "undefined") {
      memoized[param] = test;
      return test;
    }
  }
}

// node_modules/deck-of-cards/lib/translate.js
var has3d;
function translate_default(a, b, c) {
  typeof has3d !== "undefined" || (has3d = check3d());
  c = c || 0;
  if (has3d) {
    return "translate3d(" + a + ", " + b + ", " + c + ")";
  } else {
    return "translate(" + a + ", " + b + ")";
  }
}
function check3d() {
  var isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  if (!isMobile) {
    return false;
  }
  var transform = prefix_default("transform");
  var $p = document.createElement("p");
  document.body.appendChild($p);
  $p.style[transform] = "translate3d(1px,1px,1px)";
  has3d = $p.style[transform];
  has3d = has3d != null && has3d.length && has3d !== "none";
  document.body.removeChild($p);
  return has3d;
}

// node_modules/deck-of-cards/lib/modules/intro.js
var intro_default = {
  deck: function(deck) {
    deck.intro = deck.queued(intro);
    function intro(next) {
      var cards = deck.cards;
      cards.forEach(function(card, i) {
        card.setSide("front");
        card.intro(i, function(i2) {
          animationFrames_default(250, 0).start(function() {
            card.setSide("back");
          });
          if (i2 === cards.length - 1) {
            next();
          }
        });
      });
    }
  },
  card: function(card) {
    var transform = prefix_default("transform");
    var $el = card.$el;
    card.intro = function(i, cb) {
      var delay = 500 + i * 10;
      var z = i / 4;
      $el.style[transform] = translate_default(-z + "px", "-250px");
      $el.style.opacity = 0;
      card.x = -z;
      card.y = -250 - z;
      card.rot = 0;
      card.animateTo({
        delay,
        duration: 1e3,
        x: -z,
        y: -z,
        onStart: function() {
          $el.style.zIndex = i;
        },
        onProgress: function(t) {
          $el.style.opacity = t;
        },
        onComplete: function() {
          $el.style.opacity = "";
          cb && cb(i);
        }
      });
    };
  }
};

// node_modules/deck-of-cards/lib/modules/poker.js
var fontSize3;
var poker_default = {
  deck: function(deck) {
    deck.poker = deck.queued(poker);
    function poker(next) {
      var cards = deck.cards;
      var len = cards.length;
      fontSize3 = fontSize_default();
      cards.slice(-5).reverse().forEach(function(card, i) {
        card.poker(i, len, function(i2) {
          card.setSide("front");
          if (i2 === 4) {
            next();
          }
        });
      });
    }
  },
  card: function(card) {
    var $el = card.$el;
    card.poker = function(i, len, cb) {
      var delay = i * 250;
      card.animateTo({
        delay,
        duration: 250,
        x: Math.round((i - 2.05) * 70 * fontSize3 / 16),
        y: Math.round(-110 * fontSize3 / 16),
        rot: 0,
        onStart: function() {
          $el.style.zIndex = len - 1 + i;
        },
        onComplete: function() {
          cb(i);
        }
      });
    };
  }
};

// node_modules/deck-of-cards/lib/fisherYates.js
function fisherYates_default(array) {
  var rnd, temp;
  for (var i = array.length - 1; i; i--) {
    rnd = Math.random() * i | 0;
    temp = array[i];
    array[i] = array[rnd];
    array[rnd] = temp;
  }
  return array;
}

// node_modules/deck-of-cards/lib/plusminus.js
function plusminus_default(value) {
  var plusminus = Math.round(Math.random()) ? -1 : 1;
  return plusminus * value;
}

// node_modules/deck-of-cards/lib/modules/shuffle.js
var fontSize4;
var shuffle_default = {
  deck: function(deck) {
    deck.shuffle = deck.queued(shuffle);
    function shuffle(next) {
      var cards = deck.cards;
      fontSize4 = fontSize_default();
      fisherYates_default(cards);
      cards.forEach(function(card, i) {
        card.pos = i;
        card.shuffle(function(i2) {
          if (i2 === cards.length - 1) {
            next();
          }
        });
      });
      return;
    }
  },
  card: function(card) {
    var $el = card.$el;
    card.shuffle = function(cb) {
      var i = card.pos;
      var z = i / 4;
      var delay = i * 2;
      card.animateTo({
        delay,
        duration: 200,
        x: plusminus_default(Math.random() * 40 + 20) * fontSize4 / 16,
        y: -z,
        rot: 0
      });
      card.animateTo({
        delay: 200 + delay,
        duration: 200,
        x: -z,
        y: -z,
        rot: 0,
        onStart: function() {
          $el.style.zIndex = i;
        },
        onComplete: function() {
          cb(i);
        }
      });
    };
  }
};

// node_modules/deck-of-cards/lib/modules/sort.js
var sort_default = {
  deck: function(deck) {
    deck.sort = deck.queued(sort);
    function sort(next, reverse) {
      var cards = deck.cards;
      cards.sort(function(a, b) {
        if (reverse) {
          return a.i - b.i;
        } else {
          return b.i - a.i;
        }
      });
      cards.forEach(function(card, i) {
        card.sort(i, cards.length, function(i2) {
          if (i2 === cards.length - 1) {
            next();
          }
        }, reverse);
      });
    }
  },
  card: function(card) {
    var $el = card.$el;
    card.sort = function(i, len, cb, reverse) {
      var z = i / 4;
      var delay = i * 10;
      card.animateTo({
        delay,
        duration: 400,
        x: -z,
        y: -150,
        rot: 0,
        onComplete: function() {
          $el.style.zIndex = i;
        }
      });
      card.animateTo({
        delay: delay + 500,
        duration: 400,
        x: -z,
        y: -z,
        rot: 0,
        onComplete: function() {
          cb(i);
        }
      });
    };
  }
};

// node_modules/deck-of-cards/lib/modules/flip.js
var flip_default = {
  deck: function(deck) {
    deck.flip = deck.queued(flip);
    function flip(next, side) {
      var flipped = deck.cards.filter(function(card) {
        return card.side === "front";
      }).length / deck.cards.length;
      deck.cards.forEach(function(card, i) {
        card.setSide(side ? side : flipped > 0.5 ? "back" : "front");
      });
      next();
    }
  }
};

// node_modules/deck-of-cards/lib/observable.js
function observable_default(target) {
  target || (target = {});
  var listeners = {};
  target.on = on;
  target.one = one;
  target.off = off;
  target.trigger = trigger;
  return target;
  function on(name, cb, ctx) {
    listeners[name] || (listeners[name] = []);
    listeners[name].push({ cb, ctx });
  }
  function one(name, cb, ctx) {
    listeners[name] || (listeners[name] = []);
    listeners[name].push({
      cb,
      ctx,
      once: true
    });
  }
  function trigger(name) {
    var self = this;
    var args = Array.prototype.slice(arguments, 1);
    var currentListeners = listeners[name] || [];
    currentListeners.filter(function(listener) {
      listener.cb.apply(self, args);
      return !listener.once;
    });
  }
  function off(name, cb) {
    if (!name) {
      listeners = {};
      return;
    }
    if (!cb) {
      listeners[name] = [];
      return;
    }
    listeners[name] = listeners[name].filter(function(listener) {
      return listener.cb !== cb;
    });
  }
}

// node_modules/deck-of-cards/lib/queue.js
function queue_default(target) {
  var array = Array.prototype;
  var queueing = [];
  target.queue = queue;
  target.queued = queued;
  return target;
  function queued(action) {
    return function() {
      var self = this;
      var args = arguments;
      queue(function(next2) {
        action.apply(self, array.concat.apply(next2, args));
      });
    };
  }
  function queue(action) {
    if (!action) {
      return;
    }
    queueing.push(action);
    if (queueing.length === 1) {
      next();
    }
  }
  function next() {
    queueing[0](function(err) {
      if (err) {
        throw err;
      }
      queueing = queueing.slice(1);
      if (queueing.length) {
        next();
      }
    });
  }
}

// node_modules/deck-of-cards/lib/card.js
var maxZ = 52;
function card_default(i) {
  var transform = prefix_default("transform");
  var rank = i % 13 + 1;
  var suit = i / 13 | 0;
  var z = (52 - i) / 4;
  var $el = createElement_default("div");
  var $face = createElement_default("div");
  var $back = createElement_default("div");
  var isDraggable = false;
  var isFlippable = false;
  var self = { i, rank, suit, pos: i, $el, mount, unmount, setSide };
  var modules = Deck.modules;
  var module;
  $face.classList.add("face");
  $back.classList.add("back");
  $el.style[transform] = translate_default(-z + "px", -z + "px");
  self.x = -z;
  self.y = -z;
  self.z = z;
  self.rot = 0;
  self.setSide("back");
  addListener($el, "mousedown", onMousedown);
  addListener($el, "touchstart", onMousedown);
  for (module in modules) {
    addModule(modules[module]);
  }
  self.animateTo = function(params) {
    var { delay, duration, x = self.x, y = self.y, rot = self.rot, ease, onStart, onProgress, onComplete } = params;
    var startX, startY, startRot;
    var diffX, diffY, diffRot;
    animationFrames_default(delay, duration).start(function() {
      startX = self.x || 0;
      startY = self.y || 0;
      startRot = self.rot || 0;
      onStart && onStart();
    }).progress(function(t) {
      var et = ease_default[ease || "cubicInOut"](t);
      diffX = x - startX;
      diffY = y - startY;
      diffRot = rot - startRot;
      onProgress && onProgress(t, et);
      self.x = startX + diffX * et;
      self.y = startY + diffY * et;
      self.rot = startRot + diffRot * et;
      $el.style[transform] = translate_default(self.x + "px", self.y + "px") + (diffRot ? "rotate(" + self.rot + "deg)" : "");
    }).end(function() {
      onComplete && onComplete();
    });
  };
  self.setRankSuit = function(rank2, suit2) {
    var suitName = SuitName(suit2);
    $el.setAttribute("class", "card " + suitName + " rank" + rank2);
  };
  self.setRankSuit(rank, suit);
  self.enableDragging = function() {
    if (isDraggable) {
      return;
    }
    isDraggable = true;
    $el.style.cursor = "move";
  };
  self.enableFlipping = function() {
    if (isFlippable) {
      return;
    }
    isFlippable = true;
  };
  self.disableFlipping = function() {
    if (!isFlippable) {
      return;
    }
    isFlippable = false;
  };
  self.disableDragging = function() {
    if (!isDraggable) {
      return;
    }
    isDraggable = false;
    $el.style.cursor = "";
  };
  return self;
  function addModule(module2) {
    module2.card && module2.card(self);
  }
  function onMousedown(e) {
    var startPos = {};
    var pos = {};
    var starttime = Date.now();
    e.preventDefault();
    if (e.type === "mousedown") {
      startPos.x = pos.x = e.clientX;
      startPos.y = pos.y = e.clientY;
      addListener(window, "mousemove", onMousemove);
      addListener(window, "mouseup", onMouseup);
    } else {
      startPos.x = pos.x = e.touches[0].clientX;
      startPos.y = pos.y = e.touches[0].clientY;
      addListener(window, "touchmove", onMousemove);
      addListener(window, "touchend", onMouseup);
    }
    if (!isDraggable) {
      return;
    }
    $el.style[transform] = translate_default(self.x + "px", self.y + "px") + (self.rot ? " rotate(" + self.rot + "deg)" : "");
    $el.style.zIndex = maxZ++;
    function onMousemove(e2) {
      if (!isDraggable) {
        return;
      }
      if (e2.type === "mousemove") {
        pos.x = e2.clientX;
        pos.y = e2.clientY;
      } else {
        pos.x = e2.touches[0].clientX;
        pos.y = e2.touches[0].clientY;
      }
      $el.style[transform] = translate_default(Math.round(self.x + pos.x - startPos.x) + "px", Math.round(self.y + pos.y - startPos.y) + "px") + (self.rot ? " rotate(" + self.rot + "deg)" : "");
    }
    function onMouseup(e2) {
      if (isFlippable && Date.now() - starttime < 200) {
        self.setSide(self.side === "front" ? "back" : "front");
      }
      if (e2.type === "mouseup") {
        removeListener(window, "mousemove", onMousemove);
        removeListener(window, "mouseup", onMouseup);
      } else {
        removeListener(window, "touchmove", onMousemove);
        removeListener(window, "touchend", onMouseup);
      }
      if (!isDraggable) {
        return;
      }
      self.x = self.x + pos.x - startPos.x;
      self.y = self.y + pos.y - startPos.y;
    }
  }
  function mount(target) {
    target.appendChild($el);
    self.$root = target;
  }
  function unmount() {
    self.$root && self.$root.removeChild($el);
    self.$root = null;
  }
  function setSide(newSide) {
    if (newSide === "front") {
      if (self.side === "back") {
        $el.removeChild($back);
      }
      self.side = "front";
      $el.appendChild($face);
      self.setRankSuit(self.rank, self.suit);
    } else {
      if (self.side === "front") {
        $el.removeChild($face);
      }
      self.side = "back";
      $el.appendChild($back);
      $el.setAttribute("class", "card");
    }
  }
}
function SuitName(suit) {
  return suit === 0 ? "spades" : suit === 1 ? "hearts" : suit === 2 ? "clubs" : suit === 3 ? "diamonds" : "joker";
}
function addListener(target, name, listener) {
  target.addEventListener(name, listener);
}
function removeListener(target, name, listener) {
  target.removeEventListener(name, listener);
}

// node_modules/deck-of-cards/lib/deck.js
function Deck(jokers) {
  var cards = new Array(jokers ? 55 : 52);
  var $el = createElement_default("div");
  var self = observable_default({ mount, unmount, cards, $el });
  var $root;
  var modules = Deck.modules;
  var module;
  queue_default(self);
  for (module in modules) {
    addModule(modules[module]);
  }
  $el.classList.add("deck");
  var card;
  for (var i = cards.length; i; i--) {
    card = cards[i - 1] = card_default(i - 1);
    card.setSide("back");
    card.mount($el);
  }
  return self;
  function mount(root) {
    $root = root;
    $root.appendChild($el);
  }
  function unmount() {
    $root.removeChild($el);
  }
  function addModule(module2) {
    module2.deck && module2.deck(self);
  }
}
Deck.animationFrames = animationFrames_default;
Deck.ease = ease_default;
Deck.modules = { bysuit: bysuit_default, fan: fan_default, intro: intro_default, poker: poker_default, shuffle: shuffle_default, sort: sort_default, flip: flip_default };
Deck.Card = card_default;
Deck.prefix = prefix_default;
Deck.translate = translate_default;
export {
  Deck as default
};
//# sourceMappingURL=deck-of-cards.js.map
